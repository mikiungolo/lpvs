-- Questa applicazione modella un sistema Rfid, in particolare 
-- modella e verifica l'algoritmo base di anticollisione per i lettori.
-- il sistema è rappresentato da un lettore ed un numero N di tag disponibili
-- alla comunicazione con il lettore.  

-- Il lettore invia delle sonde a determinati tag nel suo raggio d'azione, 
-- i quali potranno rispondere solo tramite tale richiesta. 
-- Nel livello di astrazione scelto la sonda inviata dal Reader è rappresentata da 
-- una sequenza di bit che dinamicamente cambia fino al termine dell'algoritmo, 
-- ovvero quando tutti i tag saranno stati individuati. 
-- Un tag sarà individuato se e solo se sarà l'unico ad aver ricevuto la sonda da parte del lettore, 
-- ovvero quando il suo id è uguale a quello presente nella sonda.  

-- Nel sistema Rfid simulato i tag sono attivi, disponendo quindi di una propria alimentazione. 
-- Ogni tag ha una determinata energia casuale che una volta esaurita dopo svariate trasmissioni 
-- spegneranno automaticamente il tag rendendolo ininfluente all'interno del sistema.
-- Si osserva il caso estremo: quando un tag viene individuato con "l'ultimo livello di energia"
-- essa terminerà ma all'interno del sistema si è scelto comunque di ritenerlo identified e non spento 
-- per scelta logica. In ogni caso la seguente situazione non condiziona l'esecuzione del sistema. 

MODULE main 

VAR 
    reader: Reader(tag1, tag2, tag3, tag4, tag5, tag6, tag7, tag8);

    -- i bit sono assegnati, partendo dall'ultima posizione, secondo il cammino che va  
    -- dalla foglia di appartenenza alla radice dell'albero
    tag1  : Tag(reader, -1, -1, -1, 0, 0);
    tag2  : Tag(reader, -1, -1, 0, 1, 0); 
    tag3  : Tag(reader, -1, -1, 1, 1, 0);
    tag4  : Tag(reader, -1, -1, 0, 0, 1);
    tag5  : Tag(reader, -1, -1, 1, 0, 1);
    tag6  : Tag(reader, -1, 0, 1, 1, 1);
    tag7  : Tag(reader, 0, 1, 1, 1, 1);
    tag8  : Tag(reader, 1, 1, 1, 1, 1);

-- PROPERTY 

-- RAGGIUNGIBILITA'

-- si verifica semche effettivamente l'algoritmo è in grado di individuare tutti i tag nel proprio 
-- raggio d'azione
CTLSPEC
    AF(reader.tag_count = 0 & reader.state = end)
    
-- dopo che un tag è entrato in trasmissione prima o poi o sarà identificato
-- oppure esaurirà la sua batteria

-- verifica su tutti i tag
CTLSPEC 
    EF((tag1.state = transmitting) -> (tag1.state = identified | tag1.state = shutdown))

CTLSPEC 
    EF((tag2.state = transmitting) -> (tag2.state = identified | tag2.state = shutdown))

CTLSPEC 
    EF((tag3.state = transmitting) -> (tag3.state = identified | tag3.state = shutdown))

-- CTLSPEC 
--     EF((tag4.state = transmitting) -> (tag4.state = identified | tag4.state = shutdown))
-- ....

-- LIVENESS 

-- se tutti i tag sono stati individuati o sono rimasti senza alimentazione lungo il cammino  
-- allora l'algoritmo termina e tale condizione non varierà in nessun modo. 
CTLSPEC 
    AG(((tag1.state = identified | tag1.state = shutdown) & (tag2.state = identified | tag2.state = shutdown) & 
        (tag3.state = identified | tag3.state = shutdown) & (tag4.state = identified | tag4.state = shutdown) & (tag5.state = identified | tag5.state = shutdown) &
        (tag6.state = identified | tag6.state = shutdown) & (tag7.state = identified | tag7.state = shutdown) & (tag8.state = identified | tag8.state = shutdown)
                            -> AF((reader.state = end))))

-- LIVENESS (condizionata al turno successivo X)

-- quando sono stati identificati tutti i tag il reader  non  
-- compie più operazioni, non cambiando più il suo stato 
CTLSPEC
    AG((reader.tag_count = 0) -> AX(reader.state = end))

-- se solo un tag riceve la sonda allora il reader sarà in accettazione 
-- nel prossimo turno a meno che esso non sia l'ultimo e allora termina
CTLSPEC 
    AG((tag1.present + tag2.present + tag3.present + tag4.present + tag5.present + tag6.present + tag7.present + tag8.present 
            = 1) -> AX(reader.state = single | reader.state = end))

-- FAIRNESS DEBOLE 
-- se un tag in un dato punto è in stato di trasmissione allora 
-- il reader continuerà ad inviare le sonde fornendo un flusso continuo d'esecuzione
LTLSPEC
    F(G tag1.state = transmitting) -> G(F reader.state = send)

-- FAIRNESS FORTE
-- qualora un tag dovesse spegnersi per aver terminato la sua batteria allora non 
-- non si troverà mai presente in un futuro nodo in cui il lettore va a ricercare i tag 
-- mancanti nel sistema; quindi non potrà più comunicare con il reader. 
-- Viene verificato attraverso la variabile presente perchè attraverso lo stato del tag 
-- (GF (!tag1.transmitting) ad esempio), tale proprietà risultava banale da verificare. 
LTLSPEC
    G F(tag1.state = shutdown) -> G F(tag1.present = 0)

-- Nel seguente livello d'astrazione il Reader conosce il numero di tag presenti nel suo raggio d'azione.
-- Tale conoscenza verrà sfruttata per la verifica delle collisioni e per tenere il conto dei tag non identificati.  

MODULE Reader(tag1, tag2, tag3, tag4, tag5, tag6, tag7, tag8) 

VAR 
    state         : {send, wait, idle, collision, single, end}; -- stato dele reader 
    tag_count     : 0..8; -- contatore tag non individuati
    address       : array 0..4 of -1..1; -- indirizzo dinamico che simula il contenuto di una sonda
    no_coll_count : boolean; 

DEFINE
    -- conta il numero di tag presenti in un nodo dell'albero
    node_count   := tag1.present + tag2.present + tag3.present + tag4.present + tag5.present + tag6.present + tag7.present + tag8.present;
    
    -- conta il numero di tag che in un turno potrebbero esaurire la batteria a disposizione 
    off_count    := tag1.off + tag2.off + tag3.off + tag4.off + tag5.off + tag6.off + tag7.off + tag8.off;

    no_collision := (state = single | state = idle);

    -- esamina se è possibile tagliare l'albero delle collisioni. Non viene effettuate una stima sulla possibile  
    -- collissione ma si sfrutta la conoscenza sui tag ancora da individuare nel sistema
    clipped      := (no_coll_count & tag_count > 1);

ASSIGN

    init(state) := send;
    next(state) := 
    case
        tag_count = 0                 : end;  
        state = send                  : wait; 
        state = wait & node_count = 1 : single;         -- single quando vi è un solo tag nel nodo attivo
        state = wait & node_count > 1 : collision;      -- collision quando i tag sono almeno 2
        state = wait & node_count = 0 : idle;           -- idle se nessuno è presente
        state = idle                  : send; 
        state = collision             : send;           -- dopo aver analizzato la situazione nel nodo corrente 
        state = single                : send;           -- l'algoritmo riprende la propria iterazione inviando sonde
        TRUE                          : state; 
    esac;

    -- utile per "attivare" la versione clipped dell'algoritmo, tenendo traccia di una precedente non collisione 
    -- nell'iterazione precedente
    init(no_coll_count) := FALSE; 
    next(no_coll_count) := 
    case 
        state = single | state = idle : TRUE;
        state = collision             : FALSE;  
        TRUE                          : no_coll_count;
    esac; 

    init(tag_count) := 8;
    next(tag_count) := 
    case
        state = single & tag_count > 0         : tag_count - 1;
        tag_count > 0 & tag_count >= off_count : tag_count - off_count;   
        TRUE                                   : tag_count;
    esac;    

    -- in quest'ultima sezione del modulo READER, si modella l'indirizzo per tutte le situazioni che possono verificarsi.
    -- Si distungue per ogni stato possibile dell'indirizzo la diramazione secondo l'algoritmo clipped e secondo il base  
    -- L'indirizzo viene modellato costruendo il cammino dala foglia alla radice, quindi un percorso in questa direzione 
    -- come 100 viene rappresentato all'intenro dell'array in 100-1-1-1

    -- Quello che avviene viene così riassunto: 
    -- collisione: in questo caso l'indirizzo viene shiftato a destra per liberare la prima posizione al bit 0
    -- single o idle: 
    -- base --> si shifta l'indirizzo di n posizioni a sinistra per eliminare tutti i bit 1, e il primo bit 0 diventa 1
    -- clipped --> dalla versione base si aggiunge la logica della collisione così da attivare direttamente il nodo successivo

    init(address[0]) := -1;
    next(address[0]) := 
    case 
        state = collision                                                                                      : 0;
        no_collision & address[0] != 0 & address[1] != 0 & address[2] != 0 & address[3] != 0 & address[4] != 0 : -1;
        no_collision                                                                                           : (clipped ? 0 : 1) ; 
        TRUE                                                                                                   : address[0]; 
    esac; 

    init(address[1]) := -1;
    next(address[1]) := 
    case 
        state = collision & address[0] != -1                                             : address[0];
        no_collision & address[0] = 1 & address[1] = 1 & address[2] = 1 & address[3] = 1 : (clipped ? 1 : -1);
        no_collision & address[0] = 1 & address[1] = 1 & address[2] = 1 & address[3] = 0 : (clipped ? 1 : address[4]); 
        no_collision & address[0] = 1 & address[1] = 1 & address[2] = 0                  : (clipped ? 1 : address[3]); 
        no_collision & address[0] = 1 & address[1] = 0                                   : (clipped ? 1 : address[2]); 
        no_collision & address[0] = 0                                                    : (clipped ? 1 : address[1]) ;
        TRUE                                                                             : address[1]; 
    esac; 

    init(address[2]) := -1;
    next(address[2]) := 
    case 
        state = collision & address[0] != -1                            : address[1];
        no_collision & address[0] = 1 & address[1] = 1 & address[2] = 1 : (clipped ? address[4] : -1); 
        no_collision & address[0] = 1 & address[1] = 1 & address[2] = 0 : (clipped ? address[3] : address[4]); 
        no_collision & address[0] = 1 & address[1] = 0                  : (clipped ? address[2] : address[3]);
        no_collision & address[0] = 0                                   : (clipped ? address[1] : address[2]) ; 
        TRUE                                                            : address[2];
    esac; 

    init(address[3]) := -1;
    next(address[3]) := 
    case 
        state = collision & address[0] != -1                            : address[2];
        no_collision & address[0] = 1 & address[1] = 1 & address[2] = 0 : (clipped ? address[4] : -1); 
        no_collision & address[0] = 1 & address[1] = 0                  : (clipped ? address[3] : address[4]);
        no_collision & address[0] = 0                                   : (clipped ? address[2] : address[3]) ; 
        TRUE                                                            : address[3]; 
    esac; 

    init(address[4]) := -1;
    next(address[4]) := 
    case 
        state = collision & address[0] != -1 : address[3];
        no_collision & address[0] = 1        : (clipped ? address[4] : -1);
        no_collision & address[0] = 0        : (clipped ? address[3] : address[4]);
        TRUE                                 : address[4];
    esac;

-- Ogni tag riceve come parametri sia il lettore (a simulazione del fatto che ogni tag è in comunicazione con il lettore)
-- sia i bit che comporranno il proprio id, per simulare la funzione probabilistica per la costruzione dell'indirizzo. 
MODULE Tag(reader, b0, b1, b2, b3, b4)

VAR 
    state       : {wait, transmitting, check_single, identified, shutdown};
    present     : 0..1;     -- impostato a 1 quando si presenta nel nodo corrente puntato dal lettore
    lev_battery : -1..3;    -- -1 per un controllo. Il suo valore è associato al numero di trasmissioni possibili
    off         : 0..1; -- impostato a 1 quando è senza alimentazione

-- ogni tag confronta bit per bit l'indirizzo con l'indirizzo della sonda inviata senza considerare però i bit = -1. 
-- questa scelta sta a simulare un cammino simultaneo nell'albero delle collisioni come mostrato nel documento. 

DEFINE 
    -- indica il livello del nodo attivo, su cui il reader è "posizionato"
    lev :=     
        case
            reader.address[4] != -1 : 4;
            reader.address[3] != -1 : 3;
            reader.address[2] != -1 : 2;
            reader.address[1] != -1 : 1;
            reader.address[0] != -1 : 0;
            TRUE                    : -1;
        esac;

    -- viene fatto il confronto tra l'indirizzo del tag e della sonda del reader, quindi l'indirizzo presente
    -- per come è costruito l'indirizzo del reader e per come è inizializzato l'indirizzo del tag 
    -- si confronta l'ultimo bit utile del reader con l'ultimo bit del tag. 
    address_equal :=    
                    ((lev >= 0 -> reader.address[lev] = b4) &
                    (lev > 0 -> reader.address[lev - 1] = b3) &
                    (lev > 1 -> reader.address[lev - 2] = b2) &
                    (lev > 2 -> reader.address[lev - 3] = b1) &
                    (lev > 3 -> reader.address[lev - 4] = b0)) | 
                    lev = -1;

ASSIGN

    init(state) := wait;
    next(state) := 
    case
        lev_battery > 0 & reader.state = send & state = wait & address_equal : transmitting;
        state = transmitting                                                 : check_single; 
        reader.state = single & state = check_single                         : identified;
        lev_battery > 0 & reader.state != single & state = check_single      : wait;
        lev_battery = 0 & state != identified                                : shutdown;
        TRUE                                                                 : state; 
    esac;

    init(present) := 0;
    next(present) := 
    case
        reader.state = send & state = wait & address_equal : 1; 
        TRUE                                               : 0;
    esac;   

    -- nel momento in cui la batteria di un tag termina esso diventa inattivo all'interno di un sistema  
    -- se la batteria si esaurisce nel momento in cui esso è in solitaria in un nodo il tag viene comunque individuato 
    -- se la batteria si esaurisce dopo aver trasmesso in contemporanea ad un altro tag, quest'ultimo non verrà considerato single

    init(lev_battery) := {1, 3}; 
    next(lev_battery) := 
    case 
        lev_battery > 0 & state = transmitting : lev_battery -1; 
        lev_battery = 0 & state != shutdown    : -1;
        lev_battery = -1                       : 0;
        TRUE                                   : lev_battery; 
    esac; 

    -- come present, anche off serve a segnalare che un tag si è spento. Utile per decrementare il conteggio totale. 
    init(off) := 0; 
    next(off) := 
    case
        off = 1 | lev_battery = 0              : 0;
        lev_battery = -1 & state != identified : 1; 
        TRUE                                   : 0;
    esac; 